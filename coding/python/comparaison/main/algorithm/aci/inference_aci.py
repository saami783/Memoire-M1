import torch
import numpy as np
import networkx as nx
import torch.nn.functional as F
import torch.nn as nn
from sklearn.metrics import f1_score, precision_score, recall_score
import matplotlib.pyplot as plt

# === Composants du mod√®le ACI ===

class ACIEncoder(nn.Module):
    def __init__(self, input_dim, embed_dim):
        super().__init__()
        self.embed_dim = embed_dim
        self.linear_A = nn.Linear(input_dim, embed_dim)
        self.linear_A_comp = nn.Linear(input_dim, embed_dim)
        self.q_proj = nn.Linear(embed_dim, embed_dim)
        self.k_proj = nn.Linear(embed_dim, embed_dim)
        self.v_proj = nn.Linear(embed_dim, embed_dim)

    def forward(self, A):
        A_comp = 1.0 - A - torch.eye(A.size(0), device=A.device)
        h = F.relu(self.linear_A(A))
        h_comp = F.relu(self.linear_A_comp(A_comp))
        Q = self.q_proj(h)
        K = self.k_proj(h_comp)
        V = self.v_proj(h)
        scores = torch.matmul(Q, K.T) / np.sqrt(self.embed_dim)
        weights = F.softmax(scores, dim=-1)
        return torch.matmul(weights, V)

class ACIDecoder(nn.Module):
    def __init__(self, embed_dim, hidden_dim):
        super().__init__()
        self.lstm = nn.LSTM(embed_dim, hidden_dim, batch_first=True)
        self.output_layer = nn.Linear(hidden_dim, 1)

    def forward(self, x):
        x = x.unsqueeze(0)
        output, _ = self.lstm(x)
        return torch.sigmoid(self.output_layer(output)).squeeze(0).squeeze(-1)

class ACINet(nn.Module):
    def __init__(self, input_dim, embed_dim, hidden_dim):
        super().__init__()
        self.encoder = ACIEncoder(input_dim, embed_dim)
        self.decoder = ACIDecoder(embed_dim, hidden_dim)

    def forward(self, A):
        context = self.encoder(A)
        return self.decoder(context)

# === Utilitaires ===

def construct_vc(A, scores):
    C = set()
    covered = torch.zeros_like(A)
    for u, v in (A > 0).nonzero(as_tuple=False):
        if covered[u, v] == 0:
            chosen = u.item() if scores[u] >= scores[v] else v.item()
            C.add(chosen)
            covered[chosen, :] = 1
            covered[:, chosen] = 1
    return sorted(C)

def compute_vertex_cover_exact(A):
    G = nx.from_numpy_array(A.numpy())
    cover = set()
    uncovered_edges = set(G.edges())
    while uncovered_edges:
        degrees = dict(G.degree())
        max_node = max(degrees, key=degrees.get)
        cover.add(max_node)
        G.remove_node(max_node)
        uncovered_edges = set(G.edges())
    y = torch.zeros(A.shape[0])
    y[list(cover)] = 1.0
    return y

def compute_coverage_rate(A, cover):
    covered = torch.zeros_like(A)
    for v in cover:
        covered[v, :] = 1
        covered[:, v] = 1
    total = (A > 0).sum().item() / 2
    covered_edges = ((A * covered) > 0).sum().item() / 2
    return covered_edges / total if total > 0 else 1.0

def compute_f1(y_true, y_pred):
    return {
        'f1': f1_score(y_true, y_pred),
        'precision': precision_score(y_true, y_pred),
        'recall': recall_score(y_true, y_pred)
    }

def visualize_cover(G, cover):
    pos = nx.spring_layout(G)
    colors = ['red' if i in cover else 'lightgray' for i in G.nodes()]
    nx.draw(G, pos, with_labels=True, node_color=colors, node_size=500)
    plt.title("Couverture pr√©dite par ACI")
    plt.show()

def graph_from_g6_string(g6_str):
    G = nx.from_graph6_bytes(g6_str.encode())
    A = nx.to_numpy_array(G)
    return torch.tensor(A, dtype=torch.float32), G



# === Wrapper  ===
def aci(g6_str=None):
    torch.manual_seed(0)

    if g6_str:
        A, G = graph_from_g6_string(g6_str)
    else:
        G = nx.gnp_random_graph(20, 0.2)
        A = torch.tensor(nx.to_numpy_array(G), dtype=torch.float32)

    max_nodes = 2000
    A_padded = torch.zeros((max_nodes, max_nodes))
    A_padded[:A.shape[0], :A.shape[1]] = A

    model = ACINet(input_dim=max_nodes, embed_dim=32, hidden_dim=64)
    model.load_state_dict(torch.load("aci_model.pt"))
    model.eval()

    with torch.no_grad():
        scores = model(A_padded)[:A.shape[0]]
        predicted_cover = construct_vc(A, scores)

    y = compute_vertex_cover_exact(A)
    predicted_size = len(predicted_cover)
    optimal_size = int(y.sum().item())
    rel_diff = (100 * (predicted_size - optimal_size) / optimal_size) if optimal_size > 0 else 0

    y_pred = torch.zeros_like(y)
    y_pred[predicted_cover] = 1.0
    coverage = compute_coverage_rate(A, predicted_cover)
    metrics = compute_f1(y.numpy(), y_pred.numpy())

    # print("‚úÖ Predicted cover:", predicted_cover)
    # print("‚úÖ True cover:", list(torch.nonzero(y).squeeze().numpy()))
    # print(f"‚úÖ Taille de la couverture pr√©dite : {predicted_size}")
    # print(f"‚úÖ Taille de la couverture optimale : {optimal_size}")
    # print(f"üìè √âcart relatif : {rel_diff:.2f}%")
    # print(f"üéØ Coverage rate: {coverage * 100:.2f}%")
    # print(f"üéØ F1-score: {metrics['f1']:.4f} | Precision: {metrics['precision']:.4f} | Recall: {metrics['recall']:.4f}")

    # visualize_cover(G, predicted_cover)

    return predicted_cover, G


if __name__ == "__main__":
    perdicted_cover, G = aci("~?BG~~nTMwSmKORhAAwQGSGI@aEIOCAA`T?@G`?W?QEC?GG@Q?OOGO_H?GG?_C`O?GC?U?G?C??sA?Gg?A??G?YAOC??IA???QH???C?DCA????AE?@q????OGO??GGCC???@@O??`?O?__?A@?@a????AAc????_?G?WO???GG_C???AHG?????O@?_?C??s????A??_GCC????W_?????OCG??????K?aO??A??AoG??????@@O?????@AC?CC????A?HC??????_??cG????C@A??????C?_??A?O@???c??_A????c????_A???Go???A????A???_?W????@A?????@_????G?@O?A???WO?@??????CAO????????EKG?????????O?O@??????_C????_?CO???SO???G???????_@?????AC??P??????C@???@o????????_??C??????CW????O?A?G@?????BG??C?????????P??O?????O?????__?c???????????C?E?G????O?P??????C????K??????O?????_@O?????????_A?_???a?_???????a??????@??O???P?A???????A??CA????????G??A???@???????A?W?????A?C??@???@???A?@???????A@?????A?C???G@???BO?????C?????????G???_????C??G??O???C???A???@???C@??????????_?@_OO???????????C?@????_????????O@????O_GC?????????GC?GC?????????????C???????__??G?AGA??????????@???C????E???G?????????OG?A?????A?????A???O????C??????A???a?????C????_?????O?CC??????C??????C???@??????O?_???A?_????G??_???????O????C_???????_???G?????????`?????A?A?G??O?????????C???C?????_???O??????_??_GA?O????????????AG??????C??????G???C@@??????????A??????E???_@??????????????A?g?????C???????????o???????O??????G???GA????O???????????@?A_?????????_?????_?@G??G???_???????????T???@?????????????????O????C?C??????@????c????????O???????@??AC??????A??A???????????????_O??O????G??????`?O????????????C?????@?????_???A????G?????G?O???????????????C?@COC??????????A?????????G?????????????__?O????a??C???????????????@?A??A?????A?@?????????????????@??????????_c??????C??????????B?C??????_???????@???????@?G???_???????????O??_?G????C???O??????_???????????_o?G?????A??????????????G???_???????@???A?????????????????@_??G????G?????C?????????GG????????C??G?????C??????O???_????????????@?????????c_?????????A??G????_@?????????OC?????????E???????????????G??????OO???@?????????O?@O????@????????????????C????G????G?????_???????AO??C???????G?????????????O?_??????C???????O??????????E???@??????????@???????@???@?????????????@???O????G??_???????????C?????O?C@??????A????????????????O?O??????@@?_??????????????O??????????O???????????O?C???C??@??????????????A???_?c??__????????????????????????C??G???????_?C??????????????O????????????????C?@G??G???G?????AC???????????????O???_??????_?????????????C?OC?@????????????????????A????B??O???????????????????G????C?@???????????_???????A????_O??_?????????G???????????_??????C?????????????????_C?_????C??????????@???C???????G????CG??????A????????????????C??????????G??A??A??????????????O??????C???_????A??????@g???????????????C???????????C???_?C??????G???????????????????S??????????????G??C??????A`??????????????G??????????????????OO????????????@?????O????@A??G?????????C??????????????G_??O????????????????????????C?@O??C????A???????????????????C_??????C????????????????A????@A@?_??????????????????????????_???__?????????????@???????????C????????A_????????????????_??????????????_????G???C@???????@?C??????A???G????????????????????O??C?????A?????????????????A?@????G????G????????????G?????????P????????????????O???A???????AG???????C?????????_????????????I?????C???????????O??????????????_??_A???????????????_???????????????_???????A????????????GO?????@???????CA???????????_?????????CO??????????????????????????O??C??GO_?????@????????????????????????????????__A???????????C?????????@?_?C??????????O????????????????A@?????????????????????????_????A?")  # Remplace par une vraie cha√Æne g6 ou None pour graphe al√©atoire
    print(len(perdicted_cover))