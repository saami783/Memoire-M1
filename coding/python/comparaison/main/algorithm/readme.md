| Fichier                      | Nom de l’Algorithme / Approche     | Type                       | Fonctionnement                                                                                                |
|------------------------------|------------------------------------|----------------------------|---------------------------------------------------------------------------------------------------------------|
| **aco.py**                   | Ant Colony Optimization (ACO)      | Métaheuristique            | Utilise des “phéromones” sur les nœuds pour guider la construction de solutions et itère via évaporation.     |
| **approximate_matching.py**  | Approximate Matching Vertex Cover  | 2-approximation            | Sélectionne un sommet par arête (matching glouton) et supprime les arêtes couvertes, ratio d’env. 2.          |
| **bar_yehuda_even.py**       | Bar-Yehuda & Even Algorithm        | 2-approximation            | Ajoute les deux extrémités d’une arête non couverte, supprime les arêtes incidentes ; un classique 2-approx.  |
| **bfs.py**                   | BFS-based Heuristic                | Heuristique                | Parcours en largeur, ajoute un sommet lors de la visite d’une arête, pas de garantie sur le ratio.            |
| **degree_reduction.py**      | Degree Reduction Heuristic         | Heuristique                | Choisit en boucle un sommet (souvent de degré élevé) et le retire, jusqu’à couvrir toutes les arêtes.         |
| **dfs.py**                   | DFS-based Heuristic                | Heuristique                | Parcours en profondeur, ajoute des sommets au fil des découvertes d’arêtes, pas de ratio garanti.             |
| **edge_deletion.py**         | Edge Deletion                      | 2-approximation            | Sélectionne un sommet d’une arête non couverte, supprime les arêtes incidentes, itération jusqu’à couverture. |
| **evaluation.py**            | Script d’évaluation                | -                          | Code (non algorithmique) pour comparer/évaluer la qualité des couvertures obtenues.                           |
| **fpt.py**                   | FPT (Fixed-Parameter Tractable)    | FPT / Exact paramétré      | Recherche un cover ≤ k via branch & bound (complexité ~ O(2^k)), efficace si k petit.                         |
| **genetic.py**               | Genetic Algorithm                  | Métaheuristique            | Maintient une population, croisement et mutation de couvertures, sans local search intégré.                   |
| **gic.py**                   | Greedy Independent Cover (GIC)     | 2-approximation            | Variante gloutonne : choisit un nœud de degré minimal, couvre ses voisins, supprime, répète.                  |
| **harmony_search.py**        | Harmony Search                     | Métaheuristique            | Maintient une “mémoire” d’harmonies (solutions) et génère de nouvelles solutions par combinaison/ajustement.  |
| **ils.py**                   | Iterated Local Search (ILS)        | Métaheuristique            | Combine une recherche locale et une perturbation pour échapper aux minima locaux en itérant plusieurs fois.   |
| **local_ratio.py**           | Local Ratio Algorithm              | 2-approximation            | Similaire au matching glouton, “paye” localement pour couvrir les arêtes, ratio d’approximation de 2.         |
| **local_search.py**          | Local Search                       | Métaheuristique            | Part d’une solution (ex. matching) et l’améliore via retraits et swaps, itère jusqu’à stabilité.              |
| **lp_rounding.py**           | LP Rounding                        | 2-approximation (linéaire) | Résout la relaxation linéaire, puis arrondit les variables ≥ 0.5 pour construire un cover.                    |
| **matching_based.py**        | Matching-Based Cover               | 2-approximation            | Calcule un couplage maximal et prend les deux extrémités de chaque arête du matching.                         |
| **mdg.py**                   | Maximum Degree Greedy              | Heuristique                | Choisit le sommet de degré maximal à chaque itération, le retire, jusqu’à couvrir toutes les arêtes.          |
| **memetic.py**               | Memetic Algorithm                  | Métaheuristique            | Algorithme génétique + recherche locale (hybride) pour affiner les enfants avant insertion en population.     |
| **minimum_degree_greedy.py** | Minimum Degree Greedy              | Heuristique                | Extrême inverse : choisit en boucle un sommet de degré minimal, le retire, pas de ratio garanti.              |
| **primal_dual.py**           | Primal-Dual Vertex Cover           | 2-approximation            | Augmente des variables duales par arête, sélectionne un sommet dès que saturé, ratio de 2.                    |
| **pso.py**                   | Particle Swarm Optimization (PSO)  | Métaheuristique            | Chaque particule est un bitset, mise à jour de la vitesse et position binaire via inertie/attraction.         |
| **simulated_annealing.py**   | Simulated Annealing                | Métaheuristique            | Recherche locale stochastique qui accepte parfois des solutions plus mauvaises pour échapper aux minima.      |
| **slf.py**                   | Sorted List Left (SLF)             | Heuristique                | Trie décroissant par degré, sélectionne depuis la gauche, variation gloutonne (pas de ratio prouvé).          |
| **slr.py**                   | Sorted List Right (SLR)            | Heuristique                | Même principe que SLF, mais sélection “depuis la droite” dans la liste triée (pas de ratio prouvé).           |
| **tabu_search.py**           | Tabu Search                        | Métaheuristique            | Recherche locale maintenant une “liste tabou” pour éviter de revenir trop vite sur d’anciennes solutions.     |
| **vns.py**                   | Variable Neighborhood Search (VNS) | Métaheuristique            | Recherche locale qui change de “voisinage” pour sortir des minima (k modifications, puis k+1, etc.).          |
