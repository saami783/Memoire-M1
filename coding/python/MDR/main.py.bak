import random
import networkx as nx
import pandas as pd
import time

# Initialiser la graine pour assurer la reproductibilité des tests
SEED = 42
random.seed(SEED)


# Fonction de l'algorithme Maximum Degree Greedy
def maximum_degree_greedy(graph):
    C = set()
    temp_graph = graph.copy()

    while temp_graph.number_of_edges() > 0:
        degrees = dict(temp_graph.degree())
        max_degree = max(degrees.values())
        max_degree_nodes = [node for node, degree in degrees.items() if degree == max_degree]
        max_degree_node = random.choice(max_degree_nodes)

        C.add(max_degree_node)
        temp_graph.remove_node(max_degree_node)

    return list(C)


# Fonction de l'algorithme Greedy Independent Cover
def greedy_independent_cover(graph):
    C = set()
    temp_graph = graph.copy()

    while temp_graph.number_of_edges() > 0:
        degrees = dict(temp_graph.degree())
        min_degree = min(degrees.values())
        min_degree_nodes = [node for node, degree in degrees.items() if degree == min_degree]
        min_degree_node = random.choice(min_degree_nodes)

        neighbors = set(temp_graph.neighbors(min_degree_node))
        C.update(neighbors)

        temp_graph.remove_nodes_from(neighbors | {min_degree_node})

    return list(C)


# Fonction pour évaluer et comparer les algorithmes sur un graphe donné
def evaluate_algorithms(graph, num_runs=100, optimal_size=None):
    mdg_data = []
    gic_data = []

    for i in range(1, num_runs + 1):
        # Initialiser une graine aléatoire différente à chaque itération
        random.seed(random.randint(1, 10000))

        # Exécution et mesure du temps pour MDG
        start_time = time.time()
        mdg_solution = maximum_degree_greedy(graph)
        mdg_time = time.time() - start_time

        # Exécution et mesure du temps pour GIC
        start_time = time.time()
        gic_solution = greedy_independent_cover(graph)
        gic_time = time.time() - start_time

        # Collecte des données
        mdg_data.append({
            "Run Number": i,
            "Solution Size": len(mdg_solution),
            "Approximation Ratio": len(mdg_solution) / optimal_size if optimal_size else None,
            "Execution Time (s)": mdg_time
        })

        gic_data.append({
            "Run Number": i,
            "Solution Size": len(gic_solution),
            "Approximation Ratio": len(gic_solution) / optimal_size if optimal_size else None,
            "Execution Time (s)": gic_time
        })

    # Création de DataFrames
    mdg_df = pd.DataFrame(mdg_data)
    gic_df = pd.DataFrame(gic_data)

    # Enregistrement des résultats dans un fichier CSV
    mdg_file_path = 'mdg_results.csv'
    gic_file_path = 'gic_results.csv'
    mdg_df.to_csv(mdg_file_path, index=False)
    gic_df.to_csv(gic_file_path, index=False)

    return mdg_df, gic_df, mdg_file_path, gic_file_path


# Exemple d'utilisation
def main():
    file_path = 'benchmarks/frb50-23/cleaned/frb50-23-1_cleaned.dimacs'
    graph = nx.read_edgelist(file_path, nodetype=int)

    optimal_size = 1100  # Remplacez par la taille de la solution optimale si elle est connue

    # Évaluer sur un échantillon de 100 exécutions
    mdg_df, gic_df, mdg_file_path, gic_file_path = evaluate_algorithms(graph, num_runs=100, optimal_size=optimal_size)

    # Afficher les résultats
    print("Les résultats de l'algorithme MDG ont été enregistrés dans :", mdg_file_path)
    print("Les résultats de l'algorithme GIC ont été enregistrés dans :", gic_file_path)


if __name__ == "__main__":
    main()
